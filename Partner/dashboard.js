const express = require("express");
const router = express.Router();
const db = require("../config/db.js");

router.post("/", async (req, res) => {
    const { agent_id, filter } = req.body;
    if (!agent_id) {
        return res.status(400).json({ error: "agent_id is required" });
    }

    try {
        // 1. Fetch only confirmed or completed bookings for this agent
        const [bookings] = await db.execute(
            `SELECT * FROM bookings WHERE agent_id = ? AND status IN ('Completed', 'Upcoming', 'Confirmed')`,
            [agent_id]
        );

        // Fetch recent transactions (last 5) - also filtered
        const [recentTransactions] = await db.execute(
            `SELECT * FROM bookings WHERE agent_id = ? AND status IN ('Completed', 'Upcoming', 'Confirmed') ORDER BY booking_date DESC LIMIT 5`,
            [agent_id]
        );

        // 2. Filter logic (simulated by checking booking_date)
        const now = new Date();
        let monthsToSubtract = 6;
        if (filter === "1y") monthsToSubtract = 12;
        if (filter === "2y") monthsToSubtract = 24;
        if (filter === "3y") monthsToSubtract = 36;

        const startDate = new Date(
            now.getFullYear(),
            now.getMonth() - monthsToSubtract,
            1
        );

        const filteredBookings = bookings.filter((b) => {
            const bDate = new Date(b.booking_date);
            return bDate >= startDate;
        });

        // 3. Aggregate Stats
        let totalRevenue = 0;
        let totalOrders = filteredBookings.length;
        let activeCustomersSet = new Set();
        let serviceMap = {};
        let monthlyOrders = Array(monthsToSubtract).fill(0);

        filteredBookings.forEach((b) => {
            // Revenue
            const price = parseFloat(b.finalprice || b.totalprice || 0);
            totalRevenue += price;

            // Active Customers
            if (b.user_id) activeCustomersSet.add(b.user_id);

            // Top Services
            try {
                let services = [];
                if (typeof b.services === "string") {
                    services = JSON.parse(b.services);
                } else if (Array.isArray(b.services)) {
                    services = b.services;
                }

                services.forEach((s) => {
                    // Handle both string structure or object structure
                    const sName = typeof s === 'string' ? s : s.name || s.service_name || "Unknown";
                    serviceMap[sName] = (serviceMap[sName] || 0) + 1;
                });
            } catch (e) {
                // ignore parse error
            }

            // Chart Data (Group by month index relative to now)
            const bDate = new Date(b.booking_date);
            // Calculate month difference: (YearDiff * 12) + MonthDiff
            const monthDiff =
                (now.getFullYear() - bDate.getFullYear()) * 12 +
                (now.getMonth() - bDate.getMonth());

            // monthDiff 0 = current month, 1 = prev month, etc.
            // We need to map this to our array which is typically ordered [Oldest ... Newest] or [Newest ... Oldest]
            // Let's assume the chart expects values for labels generated by `getLabelsForMonths`
            // `getLabelsForMonths` generates labels from [Month-N ... CurrentMonth]

            // Index in array of size `monthsToSubtract`:
            // If we want array[0] to be the oldest month:
            // Index = monthsToSubtract - 1 - monthDiff
            const arrIndex = monthsToSubtract - 1 - monthDiff;
            if (arrIndex >= 0 && arrIndex < monthsToSubtract) {
                monthlyOrders[arrIndex] += 1;
            }
        });

        // 4. Determine Top Service
        let topService = "None";
        let maxCount = 0;
        Object.entries(serviceMap).forEach(([name, count]) => {
            if (count > maxCount) {
                maxCount = count;
                topService = name;
            }
        });

        // 5. Structure Top Services List
        // Convert map to array { label, value, emoji, revenue }
        // Note: We don't strictly track revenue per service type in this simple loop unless we needed to.
        // For now, let's just map count to value.
        const serviceList = Object.entries(serviceMap).map(([name, count]) => ({
            label: name,
            value: count,
            emoji: "ðŸ’‡â€â™€ï¸", // Generic emoji since we don't store emoji in db yet
            revenue: 0 // We didn't calculate per-service revenue breakdown
        })).sort((a, b) => b.value - a.value).slice(0, 5); // Top 5

        res.json({
            status: "success",
            stats: {
                totalRevenue,
                totalOrders,
                activeCustomers: activeCustomersSet.size,
                topService,
            },
            chartData: monthlyOrders,
            chartData: monthlyOrders,
            topServices: serviceList,
            recentTransactions: recentTransactions,
        });
    } catch (error) {
        console.error("Dashboard API Error:", error);
        res.status(500).json({ error: "Failed to fetch dashboard data" });
    }
});

module.exports = router;
